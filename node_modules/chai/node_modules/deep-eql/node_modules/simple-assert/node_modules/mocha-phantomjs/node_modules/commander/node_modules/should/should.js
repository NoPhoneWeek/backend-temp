/*!
 * should - test framework agnostic BDD-style assertions
 * @version v9.0.2
 * @author TJ Holowaychuk <tj@vision-media.ca>, Denis Bardadym <bardadymchik@gmail.com> and other contributors
 * @link https://github.com/shouldjs/should.js
 * @license MIT
 */

(function (root) {
  'use strict';

  var types = {
    NUMBER: 'number',
    UNDEFINED: 'undefined',
    STRING: 'string',
    BOOLEAN: 'boolean',
    OBJECT: 'object',
    FUNCTION: 'function',
    NULL: 'null',
    ARRAY: 'array',
    REGEXP: 'regexp',
    DATE: 'date',
    ERROR: 'error',
    ARGUMENTS: 'arguments',
    SYMBOL: 'symbol',
    ARRAY_BUFFER: 'array-buffer',
    TYPED_ARRAY: 'typed-array',
    DATA_VIEW: 'data-view',
    MAP: 'map',
    SET: 'set',
    WEAK_SET: 'weak-set',
    WEAK_MAP: 'weak-map',
    PROMISE: 'promise',

  // node buffer
    BUFFER: 'buffer',

  // dom html element
    HTML_ELEMENT: 'html-element',
    HTML_ELEMENT_TEXT: 'html-element-text',
    DOCUMENT: 'document',
    WINDOW: 'window',
    FILE: 'file',
    FILE_LIST: 'file-list',
    BLOB: 'blob',

    HOST: 'host',

    XHR: 'xhr',

    // simd
    SIMD: 'simd'
  };

  var toString = Object.prototype.toString;

  /**
   * Simple data function to store type information
   * @param {string} type Usually what is returned from typeof
   * @param {string} cls  Sanitized @Class via Object.prototype.toString
   * @param {string} sub  If type and cls the same, and need to specify somehow
   * @private
   * @example
   *
   * //for null
   * new Type('null');
   *
   * //for Date
   * new Type('object', 'date');
   *
   * //for Uint8Array
   *
   * new Type('object', 'typed-array', 'uint8');
   */
  function Type(type, cls, sub) {
    this.type = type;
    this.cls = cls;
    this.sub = sub;
  }

  /**
   * Function to store type checks
   * @private
   */
  function TypeChecker() {
    this.checks = [];
  }

  TypeChecker.prototype = {
    add: function(func) {
      this.checks.push(func);
      return this;
    },

    addTypeOf: function(type, res) {
      return this.add(function(obj, tpeOf) {
        if(tpeOf === type) {
          return new Type(res);
        }
      });
    },

    addClass: function(cls, res, sub) {
      return this.add(function(obj, tpeOf, objCls) {
        if(objCls === cls) {
          return new Type(types.OBJECT, res, sub);
        }
      });
    },

    getType: function(obj) {
      var typeOf = typeof obj;
      var cls = toString.call(obj);

      for(var i = 0, l = this.checks.length; i < l; i++) {
        var res = this.checks[i].call(this, obj, typeOf, cls);
        if(typeof res !== 'undefined') return res;
      }

    }
  };

  var main = new TypeChecker();

  //TODO add iterators

  main
    .addTypeOf(types.NUMBER, types.NUMBER)
    .addTypeOf(types.UNDEFINED, types.UNDEFINED)
    .addTypeOf(types.STRING, types.STRING)
    .addTypeOf(types.BOOLEAN, types.BOOLEAN)
    .addTypeOf(types.FUNCTION, types.FUNCTION)
    .addTypeOf(types.SYMBOL, types.SYMBOL)
    .add(function(obj, tpeOf) {
      if(obj === null) return new Type(types.NULL);
    })
    .addClass('[object String]', types.STRING)
    .addClass('[object Boolean]', types.BOOLEAN)
    .addClass('[object Number]', types.NUMBER)
    .addClass('[object Array]', types.ARRAY)
    .addClass('[object RegExp]', types.REGEXP)
    .addClass('[object Error]', types.ERROR)
    .addClass('[object Date]', types.DATE)
    .addClass('[object Arguments]', types.ARGUMENTS)

    .addClass('[object ArrayBuffer]', types.ARRAY_BUFFER)
    .addClass('[object Int8Array]', types.TYPED_ARRAY, 'int8')
    .addClass('[object Uint8Array]', types.TYPED_ARRAY, 'uint8')
    .addClass('[object Uint8ClampedArray]', types.TYPED_ARRAY, 'uint8clamped')
    .addClass('[object Int16Array]', types.TYPED_ARRAY, 'int16')
    .addClass('[object Uint16Array]', types.TYPED_ARRAY, 'uint16')
    .addClass('[object Int32Array]', types.TYPED_ARRAY, 'int32')
    .addClass('[object Uint32Array]', types.TYPED_ARRAY, 'uint32')
    .addClass('[object Float32Array]', types.TYPED_ARRAY, 'float32')
    .addClass('[object Float64Array]', types.TYPED_ARRAY, 'float64')

    .addClass('[object Bool16x8]', types.SIMD, 'bool16x8')
    .addClass('[object Bool32x4]', types.SIMD, 'bool32x4')
    .addClass('[object Bool8x16]', types.SIMD, 'bool8x16')
    .addClass('[object Float32x4]', types.SIMD, 'float32x4')
    .addClass('[object Int16x8]', types.SIMD, 'int16x8')
    .addClass('[object Int32x4]', types.SIMD, 'int32x4')
    .addClass('[object Int8x16]', types.SIMD, 'int8x16')
    .addClass('[object Uint16x8]', types.SIMD, 'uint16x8')
    .addClass('[object Uint32x4]', types.SIMD, 'uint32x4')
    .addClass('[object Uint8x16]', types.SIMD, 'uint8x16')

    .addClass('[object DataView]', types.DATA_VIEW)
    .addClass('[object Map]', types.MAP)
    .addClass('[object WeakMap]', types.WEAK_MAP)
    .addClass('[object Set]', types.SET)
    .addClass('[object WeakSet]', types.WEAK_SET)
    .addClass('[object Promise]', types.PROMISE)
    .addClass('[object Blob]', types.BLOB)
    .addClass('[object File]', types.FILE)
    .addClass('[object FileList]', types.FILE_LIST)
    .addClass('[object XMLHttpRequest]', types.XHR)
    .add(function(obj) {
      if((typeof Promise === types.FUNCTION && obj instanceof Promise) ||
          (typeof obj.then === types.FUNCTION)) {
            return new Type(types.OBJECT, types.PROMISE);
          }
    })
    .add(function(obj) {
      if(typeof Buffer !== 'undefined' && obj instanceof Buffer) {
        return new Type(types.OBJECT, types.BUFFER);
      }
    })
    .add(function(obj) {
      if(typeof Node !== 'undefined' && obj instanceof Node) {
        return new Type(types.OBJECT, types.HTML_ELEMENT, obj.nodeName);
      }
    })
    .add(function(obj) {
      // probably at the begginging should be enough these checks
      if(obj.Boolean === Boolean && obj.Number === Number && obj.String === String && obj.Date === Date) {
        return new Type(types.OBJECT, types.HOST);
      }
    })
    .add(function() {
      return new Type(types.OBJECT);
    });

  /**
   * Get type information of anything
   *
   * @param  {any} obj Anything that could require type information
   * @return {Type}    type info
   * @private
   */
  function getGlobalType(obj) {
    return main.getType(obj);
  }

  getGlobalType.checker = main;
  getGlobalType.TypeChecker = TypeChecker;
  getGlobalType.Type = Type;

  Object.keys(types).forEach(function(typeName) {
    getGlobalType[typeName] = types[typeName];
  });

  var EOL = '\n';

  function indent$1(v, indentation) {
    return v
      .split(EOL)
      .map(function(vv) {
        return indentation + vv;
      })
      .join(EOL);
  }

  function pad(str, value, filler) {
    str = String(str)
    var isRight = false;

    if(value < 0) {
      isRight = true;
      value = -value;
    }

    if(str.length < value) {
      var padding = new Array(value - str.length + 1).join(filler);
      return isRight ? str + padding : padding + str;
    } else{
      return str;
    }
  }

  function pad0(str, value) {
    return pad(str, value, '0');
  }

  function genKeysFunc(f) {
    return function(value) {
      var k = f(value);
      k.sort();
      return k;
    };
  }

  var INDENT = '  ';

  function addSpaces(str) {
    return indent$1(str, INDENT);
  }


  function Formatter(opts) {
    opts = opts || {};

    this.seen = [];
    var keysFunc;
    if(typeof opts.keysFunc === 'function') {
      keysFunc = opts.keysFunc;
    } else if(opts.keys === false) {
      keysFunc = Object.getOwnPropertyNames;
    } else {
      keysFunc = Object.keys;
    }

    this.keys = genKeysFunc(keysFunc);

    this.maxLineLength = typeof opts.maxLineLength === 'number' ? opts.maxLineLength : 60;
    this.propSep = opts.propSep || ',';

    this.isUTCdate = !!opts.isUTCdate;
  }

  Formatter.prototype = {
    constructor: Formatter,

    format: function(value) {
      var t = getGlobalType(value);
      var name1 = t.type, name2 = t.type;
      if(t.cls) {
        name1 += '_' + t.cls;
        name2 += '_' + t.cls;
      }
      if(t.sub) {
        name2 += '_' + t.sub;
      }
      var f = this['_format_' + name2] || this['_format_' + name1] || this['_format_' + t.type] || this.defaultFormat;
      return f.call(this, value).trim();
    },

    _formatObject: function(value, opts) {
      opts = opts || {};
      var mainKeys = opts.keys || this.keys(value);

      var len = 0;

      var formatPropertyValue = opts.formatPropertyValue || this.formatPropertyValue;
      var formatPropertyName = opts.formatPropertyName || this.formatPropertyName;
      var keyValueSep = opts.keyValueSep || ': ';
      var keyFilter = opts.keyFilter || function() { return true; };

      this.seen.push(value);
      var keys = [];

      mainKeys.forEach(function(key) {
        if(!keyFilter(key)) return;

        var fName = formatPropertyName.call(this, key);

        var f = (fName ? fName + keyValueSep : '') + formatPropertyValue.call(this, value, key);
        len += f.length;
        keys.push(f);
      }, this);
      this.seen.pop();

      (opts.additionalProperties || []).forEach(function(keyValue) {
        var f = keyValue[0] + keyValueSep + this.format(keyValue[1]);
        len += f.length;
        keys.push(f);
      }, this);

      var prefix = opts.prefix || Formatter.constructorName(value) || '';
      if(prefix.length > 0) prefix += ' ';

      var lbracket, rbracket;
      if(Array.isArray(opts.brackets)) {
        lbracket = opts.brackets && opts.brackets[0];
        rbracket = opts.brackets && opts.brackets[1];
      } else {
        lbracket = '{';
        rbracket = '}';
      }

      var rootValue = opts.value || '';

      if(keys.length === 0)
        return rootValue || (prefix + lbracket + rbracket);

      if(len <= this.maxLineLength) {
        return prefix + lbracket + ' ' + (rootValue ? rootValue + ' ' : '') + keys.join(this.propSep + ' ') + ' ' + rbracket;
      } else {
        return prefix + lbracket + '\n' + (rootValue ? '  ' + rootValue + '\n' : '') + keys.map(addSpaces).join(this.propSep + '\n') + '\n' + rbracket;
      }
    },

    formatPropertyName: function(name) {
      return name.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*$/) ? name : this.format(name);
    },

    formatProperty: function(value, prop) {
      var desc = Formatter.getPropertyDescriptor(value, prop);

      var propName = this.formatPropertyName(prop);

      var propValue = desc.get && desc.set ?
        '[Getter/Setter]' : desc.get ?
        '[Getter]' : desc.set ?
        '[Setter]' : this.seen.indexOf(desc.value) >= 0 ?
        '[Circular]' :
        this.format(desc.value);

      return propName + ': ' + propValue;
    },

    formatPropertyValue: function(value, prop) {
      var desc = Formatter.getPropertyDescriptor(value, prop);

      var propValue = desc.get && desc.set ?
        '[Getter/Setter]' : desc.get ?
        '[Getter]' : desc.set ?
        '[Setter]' : this.seen.indexOf(desc.value) >= 0 ?
        '[Circular]' :
        this.format(desc.value);

      return propValue;
    }
  };

  Formatter.add = function add(type, cls, sub, f) {
    var args = Array.prototype.slice.call(arguments);
    f = args.pop();
    Formatter.prototype['_format_' + args.join('_')] = f;
  };


  var functionNameRE = /^\s*function\s*(\S*)\s*\(/;

  Formatter.functionName = function functionName(f) {
    if(f.name) {
      return f.name;
    }
    var matches = f.toString().match(functionNameRE);
    if (matches === null) {
      // `functionNameRE` doesn't match arrow functions.
      return '';
    }
    var name = matches[1];
    return name;
  };

  Formatter.constructorName = function(obj) {
    while (obj) {
      var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
      if (descriptor !== undefined &&
          typeof descriptor.value === 'function') {

          var name = Formatter.functionName(descriptor.value);
          if(name !== '') {
            return name;
          }
      }

      obj = Object.getPrototypeOf(obj);
    }
  };

  Formatter.getPropertyDescriptor = function(obj, value) {
    var desc;
    try {
      desc = Object.getOwnPropertyDescriptor(obj, value) || {value: obj[value]};
    } catch(e) {
      desc = {value: e};
    }
    return desc;
  };

  Formatter.generateFunctionForIndexedArray = function generateFunctionForIndexedArray(lengthProp, name, padding) {
    return function(value) {
      var max = this.byteArrayMaxLength || 50;
      var length = value[lengthProp];
      var formattedValues = [];
      var len = 0;
      for(var i = 0; i < max && i < length; i++) {
        var b = value[i] || 0;
        var v = pad0(b.toString(16), padding);
        len += v.length;
        formattedValues.push(v);
      }
      var prefix = value.constructor.name || name || '';
      if(prefix) prefix += ' ';

      if(formattedValues.length === 0)
        return prefix + '[]';

      if(len <= this.maxLineLength) {
        return prefix + '[ ' + formattedValues.join(this.propSep + ' ') + ' ' + ']';
      } else {
        return prefix + '[\n' + formattedValues.map(addSpaces).join(this.propSep + '\n') + '\n' + ']';
      }
    };
  };

  Formatter.add('undefined', function() { return 'undefined' });
  Formatter.add('null', function() { return 'null' });
  Formatter.add('boolean', function(value) { return value ? 'true': 'false' });
  Formatter.add('symbol', function(value) { return value.toString() });

  ['number', 'boolean'].forEach(function(name) {
    Formatter.add('object', name, function(value) {
      return this._formatObject(value, {
        additionalProperties: [['[[PrimitiveValue]]', value.valueOf()]]
      });
    });
  });

  Formatter.add('object', 'string', function(value) {
    var realValue = value.valueOf();

    return this._formatObject(value, {
      keyFilter: function(key) {
        //skip useless indexed properties
        return !(key.match(/\d+/) && parseInt(key, 10) < realValue.length);
      },
      additionalProperties: [['[[PrimitiveValue]]', realValue]]
    });
  });

  Formatter.add('object', 'regexp', function(value) {
    return this._formatObject(value, {
      value: String(value)
    });
  });

  Formatter.add('number', function(value) {
    if(value === 0 && 1 / value < 0) return '-0';
    return String(value);
  });

  Formatter.add('string', function(value) {
    return '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
        .replace(/'/g, "\\'")
        .replace(/\\"/g, '"') + '\'';
  });

  Formatter.add('object', function(value) {
    return this._formatObject(value);
  });

  Formatter.add('object', 'arguments', function(value) {
    return this._formatObject(value, {
      prefix: 'Arguments',
      formatPropertyName: function(key) {
        if(!key.match(/\d+/)) {
          return this.formatPropertyName(key);
        }
      },
      brackets: ['[', ']']
    });
  });

  Formatter.add('object', 'array', function(value) {
    return this._formatObject(value, {
      formatPropertyName: function(key) {
        if(!key.match(/\d+/)) {
          return this.formatPropertyName(key);
        }
      },
      brackets: ['[', ']']
    });
  });


  function formatDate(value, isUTC) {
    var prefix = isUTC ? 'UTC' : '';

    var date = value['get' + prefix + 'FullYear']() +
      '-' +
      pad0(value['get' + prefix + 'Month']() + 1, 2) +
      '-' +
      pad0(value['get' + prefix + 'Date'](), 2);

    var time = pad0(value['get' + prefix + 'Hours'](), 2) +
      ':' +
      pad0(value['get' + prefix + 'Minutes'](), 2) +
      ':' +
      pad0(value['get' + prefix + 'Seconds'](), 2) +
      '.' +
      pad0(value['get' + prefix + 'Milliseconds'](), 3);

    var to = value.getTimezoneOffset();
    var absTo = Math.abs(to);
    var hours = Math.floor(absTo / 60);
    var minutes = absTo - hours * 60;
    var tzFormat = (to < 0 ? '+' : '-') + pad0(hours, 2) + pad0(minutes, 2);

    return date + ' ' + time + (isUTC ? '' : ' ' + tzFormat);
  }

  Formatter.add('object', 'date', function(value) {
    return this._formatObject(value, { value: formatDate(value, this.isUTCdate) });
  });

  Formatter.add('function', function(value) {
    return this._formatObject(value, {
      additionalProperties: [['name', Formatter.functionName(value)]]
    });
  });

  Formatter.add('object', 'error', function(value) {
    return this._formatObject(value, {
      prefix: value.name,
      additionalProperties: [['message', value.message]]
    });
  });

  Formatter.add('object', 'buffer', Formatter.generateFunctionForIndexedArray('length', 'Buffer', 2));

  Formatter.add('object', 'array-buffer', Formatter.generateFunctionForIndexedArray('byteLength', 'ArrayBuffer', 2));

  Formatter.add('object', 'typed-array', 'int8', Formatter.generateFunctionForIndexedArray('length', 'Int8Array', 2));
  Formatter.add('object', 'typed-array', 'uint8', Formatter.generateFunctionForIndexedArray('length', 'Uint8Array', 2));
  Formatter.add('object', 'typed-array', 'uint8clamped', Formatter.generateFunctionForIndexedArray('length', 'Uint8ClampedArray', 2));

  Formatter.add('object', 'typed-array', 'int16', Formatter.generateFunctionForIndexedArray('length', 'Int16Array', 4));
  Formatter.add('object', 'typed-array', 'uint16', Formatter.generateFunctionForIndexedArray('length', 'Uint16Array', 4));

  Formatter.add('object', 'typed-array', 'int32', Formatter.generateFunctionForIndexedArray('length', 'Int32Array', 8));
  Formatter.add('object', 'typed-array', 'uint32', Formatter.generateFunctionForIndexedArray('length', 'Uint32Array', 8));

  //TODO add float32 and float64

  Formatter.add('object', 'promise', function() {
    return '[Promise]';//TODO it could be nice to inspect its state and value
  });

  Formatter.add('object', 'xhr', function() {
    return '[XMLHttpRequest]';//TODO it could be nice to inspect its state
  });

  Formatter.add('object', 'html-element', function(value) {
    return value.outerHTML;
  });

  Formatter.add('object', 'html-element', '#text', function(value) {
    return value.nodeValue;
  });

  Formatter.add('object', 'html-element', '#document', function(value) {
    return value.documentElement.outerHTML;
  });

  Formatter.add('object', 'host', function() {
    return '[Host]';
  });

  Formatter.add('object', 'set', function(value) {
    var iter = value.values();
    var len = 0;

    this.seen.push(value);

    var props = [];

    var next = iter.next();
    while(!next.done) {
      var val = next.value;
      var f = this.format(val);
      len += f.length;
      props.push(f);

      next = iter.next();
    }

    this.seen.pop();

    if(props.length === 0) return 'Set {}';

    if(len <= this.maxLineLength) {
      return 'Set { ' + props.join(this.propSep + ' ') + ' }';
    } else {
      return 'Set {\n' + props.map(addSpaces).join(this.propSep + '\n') + '\n' + '}';
    }
  });

  Formatter.add('object', 'map', function(value) {
    var iter = value.entries();
    var len = 0;

    this.seen.push(value);

    var props = [];

    var next = iter.next();
    while(!next.done) {
      var val = next.value;
      var fK = this.format(val[0]);
      var fV = this.format(val[1]);

      var f;
      if((fK.length + fV.length + 4) <= this.maxLineLength) {
        f = fK + ' => ' + fV;
      } else {
        f = fK + ' =>\n' + fV;
      }

      len += fK.length + fV.length + 4;
      props.push(f);

      next = iter.next();
    }

    this.seen.pop();

    if(props.length === 0) return 'Map {}';

    if(len <= this.maxLineLength) {
      return 'Map { ' + props.join(this.propSep + ' ') + ' }';
    } else {
      return 'Map {\n' + props.map(addSpaces).join(this.propSep + '\n') + '\n' + '}';
    }
  });

  function simdVectorFormat(constructorName, length) {
    return function(value) {
      var Constructor = value.constructor;
      var extractLane = Constructor.extractLane;

      var len = 0;
      var props = [];

      for(var i = 0; i < length; i ++) {
        var key = this.format(extractLane(value, i));
        len += key.length;
        props.push(key);
      }

      if(len <= this.maxLineLength) {
        return constructorName + ' [ ' + props.join(this.propSep + ' ') + ' ]';
      } else {
        return constructorName + ' [\n' + props.map(addSpaces).join(this.propSep + '\n') + '\n' + ']';
      }
    }
  }

  Formatter.add('object', 'simd', 'bool16x8', simdVectorFormat('Bool16x8', 8));
  Formatter.add('object', 'simd', 'bool32x4', simdVectorFormat('Bool32x4', 4));
  Formatter.add('object', 'simd', 'bool8x16', simdVectorFormat('Bool8x16', 16));
  Formatter.add('object', 'simd', 'float32x4', simdVectorFormat('Float32x4', 4));
  Formatter.add('object', 'simd', 'int16x8', simdVectorFormat('Int16x8', 8));
  Formatter.add('object', 'simd', 'int32x4', simdVectorFormat('Int32x4', 4));
  Formatter.add('object', 'simd', 'int8x16', simdVectorFormat('Int8x16', 16));
  Formatter.add('object', 'simd', 'uint16x8', simdVectorFormat('Uint16x8', 8));
  Formatter.add('object', 'simd', 'uint32x4', simdVectorFormat('Uint32x4', 4));
  Formatter.add('object', 'simd', 'uint8x16', simdVectorFormat('Uint8x16', 16));

  Formatter.prototype.defaultFormat = Formatter.prototype._format_object;

  function defaultFormat(value, opts) {
    return new Formatter(opts).format(value);
  }

  defaultFormat.Formatter = Formatter;

  function format$1(msg) {
    var args = arguments;
    for (var i = 1, l = args.length; i < l; i++) {
      msg = msg.replace(/%s/, args[i]);
    }
    return msg;
  }

  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

  function EqualityFail(a, b, reason, path) {
    this.a = a;
    this.b = b;
    this.reason = reason;
    this.path = path;
  }

  function typeToString(t) {
    return t.type + (t.cls ? '(' + t.cls + (t.sub ? ' ' + t.sub : '') + ')' : '');
  }

  var  PLUS_0_AND_MINUS_0 = '+0 is not equal to -0';
  var  DIFFERENT_TYPES = 'A has type %s and B has type %s';
  var  EQUALITY = 'A is not equal to B';
  var  EQUALITY_PROTOTYPE = 'A and B have different prototypes';
  var  WRAPPED_VALUE = 'A wrapped value is not equal to B wrapped value';
  var  FUNCTION_SOURCES = 'function A is not equal to B by source code value (via .toString call)';
  var  MISSING_KEY = '%s has no key %s';
  var  SET_MAP_MISSING_KEY = 'Set/Map missing key %s';


  var DEFAULT_OPTIONS = {
    checkProtoEql: true,
    checkSubType: true,
    plusZeroAndMinusZeroEqual: true,
    collectAllFails: false
  };

  function setBooleanDefault(property, obj, opts, defaults) {
    obj[property] = typeof opts[property] !== 'boolean' ? defaults[property] : opts[property];
  }

  var METHOD_PREFIX = '_check_';

  function EQ(opts, a, b, path) {
    opts = opts || {};

    setBooleanDefault('checkProtoEql', this, opts, DEFAULT_OPTIONS);
    setBooleanDefault('plusZeroAndMinusZeroEqual', this, opts, DEFAULT_OPTIONS);
    setBooleanDefault('checkSubType', this, opts, DEFAULT_OPTIONS);
    setBooleanDefault('collectAllFails', this, opts, DEFAULT_OPTIONS);

    this.a = a;
    this.b = b;

    this._meet = opts._meet || [];

    this.fails = opts.fails || [];

    this.path = path || [];
  }

  function ShortcutError(fail) {
    this.name = 'ShortcutError';
    this.message = 'fail fast';
    this.fail = fail;
  }

  ShortcutError.prototype = Object.create(Error.prototype);

  EQ.checkStrictEquality = function(a, b) {
    this.collectFail(a !== b, EQUALITY);
  };

  EQ.add = function add(type, cls, sub, f) {
    var args = Array.prototype.slice.call(arguments);
    f = args.pop();
    EQ.prototype[METHOD_PREFIX + args.join('_')] = f;
  };

  EQ.prototype = {
    check: function() {
      try {
        this.check0();
      } catch (e) {
        if (e instanceof ShortcutError) {
          return [e.fail];
        }
        throw e;
      }
      return this.fails;
    },

    check0: function() {
      var a = this.a;
      var b = this.b;

      // equal a and b exit early
      if (a === b) {
        // check for +0 !== -0;
        return this.collectFail(a === 0 && (1 / a !== 1 / b) && !this.plusZeroAndMinusZeroEqual, PLUS_0_AND_MINUS_0);
      }

      var typeA = getGlobalType(a);
      var typeB = getGlobalType(b);

      // if objects has different types they are not equal
      var typeDifferent = typeA.type !== typeB.type || typeA.cls !== typeB.cls;

      if (typeDifferent || ((this.checkSubType && typeA.sub !== typeB.sub) || !this.checkSubType)) {
        return this.collectFail(true, format$1(DIFFERENT_TYPES, typeToString(typeA), typeToString(typeB)));
      }

      // as types the same checks type specific things
      var name1 = typeA.type, name2 = typeA.type;
      if (typeA.cls) {
        name1 += '_' + typeA.cls;
        name2 += '_' + typeA.cls;
      }
      if (typeA.sub) {
        name2 += '_' + typeA.sub;
      }

      var f = this[METHOD_PREFIX + name2] || this[METHOD_PREFIX + name1] || this[METHOD_PREFIX + typeA.type] || this.defaultCheck;

      f.call(this, this.a, this.b);
    },

    collectFail: function(comparison, reason, showReason) {
      if (comparison) {
        var res = new EqualityFail(this.a, this.b, reason, this.path);
        res.showReason = !!showReason;

        this.fails.push(res);

        if (!this.collectAllFails) {
          throw new ShortcutError(res);
        }
      }
    },

    checkPlainObjectsEquality: function(a, b) {
      // compare deep objects and arrays
      // stacks contain references only
      //
      var meet = this._meet;
      var m = this._meet.length;
      while (m--) {
        var st = meet[m];
        if (st[0] === a && st[1] === b) {
          return;
        }
      }

      // add `a` and `b` to the stack of traversed objects
      meet.push([a, b]);

      // TODO maybe something else like getOwnPropertyNames
      var key;
      for (key in b) {
        if (hasOwnProperty$1.call(b, key)) {
          if (hasOwnProperty$1.call(a, key)) {
            this.checkPropertyEquality(key);
          } else {
            this.collectFail(true, format$1(MISSING_KEY, 'A', key));
          }
        }
      }

      // ensure both objects have the same number of properties
      for (key in a) {
        if (hasOwnProperty$1.call(a, key)) {
          this.collectFail(!hasOwnProperty$1.call(b, key), format$1(MISSING_KEY, 'B', key));
        }
      }

      meet.pop();

      if (this.checkProtoEql) {
        //TODO should i check prototypes for === or use eq?
        this.collectFail(Object.getPrototypeOf(a) !== Object.getPrototypeOf(b), EQUALITY_PROTOTYPE, true);
      }

    },

    checkPropertyEquality: function(propertyName) {
      var eq = new EQ(this, this.a[propertyName], this.b[propertyName], this.path.concat([propertyName]));
      eq.check0();
    },

    defaultCheck: EQ.checkStrictEquality
  };


  EQ.add('number', function(a, b) {
    this.collectFail((a !== a && b === b) || (b !== b && a === a) || (a !== b && a === a && b === b), EQUALITY);
  });

  ['symbol', 'boolean', 'string'].forEach(function(tp) {
    EQ.add(tp, EQ.checkStrictEquality);
  });

  EQ.add('function', function(a, b) {
    // functions are compared by their source code
    this.collectFail(a.toString() !== b.toString(), FUNCTION_SOURCES);
    // check user properties
    this.checkPlainObjectsEquality(a, b);
  });

  EQ.add('object', 'regexp', function(a, b) {
    // check regexp flags
    var flags = ['source', 'global', 'multiline', 'lastIndex', 'ignoreCase', 'sticky', 'unicode'];
    while (flags.length) {
      this.checkPropertyEquality(flags.shift());
    }
    // check user properties
    this.checkPlainObjectsEquality(a, b);
  });

  EQ.add('object', 'date', function(a, b) {
    //check by timestamp only (using .valueOf)
    this.collectFail(+a !== +b, EQUALITY);
    // check user properties
    this.checkPlainObjectsEquality(a, b);
  });

  ['number', 'boolean', 'string'].forEach(function(tp) {
    EQ.add('object', tp, function(a, b) {
      //primitive type wrappers
      this.collectFail(a.valueOf() !== b.valueOf(), WRAPPED_VALUE);
      // check user properties
      this.checkPlainObjectsEquality(a, b);
    });
  });

  EQ.add('object', function(a, b) {
    this.checkPlainObjectsEquality(a, b);
  });

  ['array', 'arguments', 'typed-array'].forEach(function(tp) {
    EQ.add('object', tp, function(a, b) {
      this.checkPropertyEquality('length');

      this.checkPlainObjectsEquality(a, b);
    });
  });

  EQ.add('object', 'array-buffer', function(a, b) {
    this.checkPropertyEquality('byteLength');

    this.checkPlainObjectsEquality(a, b);
  });

  EQ.add('object', 'error', function(a, b) {
    this.checkPropertyEquality('name');
    this.checkPropertyEquality('message');

    this.checkPlainObjectsEquality(a, b);
  });

  EQ.add('object', 'buffer', function(a) {
    this.checkPropertyEquality('length');

    var l = a.length;
    while (l--) {
      this.checkPropertyEquality(l);
    }

    //we do not check for user properties because
    //node Buffer have some strange hidden properties
  });

  ['map', 'set'].forEach(function(tp) {
    EQ.add('object', tp, function(a, b) {
      this._meet.push([a, b]);

      var iteratorA = a.entries();
      for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {

        var iteratorB = b.entries();
        var keyFound = false;
        for (var nextB = iteratorB.next(); !nextB.done; nextB = iteratorB.next()) {
          // try to check keys first
          var r = eq(nextA.value[0], nextB.value[0], { collectAllFails: false, _meet: this._meet });

          if (r.length === 0) {
            keyFound = true;

            // check values also
            eq(nextA.value[1], nextB.value[1], this);
          }
        }

        if (!keyFound) {
          // no such key at all
          this.collectFail(true, format$1(SET_MAP_MISSING_KEY, nextA.value[0]));
        }
      }

      this._meet.pop();

      this.checkPlainObjectsEquality(a, b);
    });
  });


  function eq(a, b, opts) {
    return new EQ(opts, a, b).check();
  }

  eq.EQ = EQ;

  var config = {
    getFormatter: function(opts) {
      return new defaultFormat.Formatter(opts || config);
    }
  };

  /**
   * Check if given obj just a primitive type wrapper
   * @param {Object} obj
   * @returns {boolean}
   * @private
   */
  function isWrapperType(obj) {
    return obj instanceof Number ||
      obj instanceof String ||
      obj instanceof Boolean;
  }

  function merge(a, b) {
    if (a && b) {
      for (var key in b) {
        a[key] = b[key];
      }
    }
    return a;
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function forEach(obj, f, context) {
    if (isGeneratorFunction(obj)) {
      return forEach(obj(), f, context);
    } else if (isGeneratorObject(obj)) {
      var value = obj.next();
      while (!value.done) {
        if (f.call(context, value.value, 'value', obj) === false) {
          return;
        }
        value = obj.next();
      }
    } else {
      for (var prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
          if (f.call(context, obj[prop], prop, obj) === false) {
            return;
          }
        }
      }
    }
  }

  function some(obj, f, context) {
    var res = false;
    forEach(obj, function(value, key) {
      if (f.call(context, value, key, obj)) {
        res = true;
        return false;
      }
    }, context);
    return res;
  }

  function isEmptyObject(obj) {
    for (var prop in obj) {
      if (hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  }

  function isIndexable(obj) {
    var t = getGlobalType(obj);
    return (t.type === 'object' && (
        t.cls === 'array' ||
        t.cls === 'buffer' ||
        t.cls === 'arguments' ||
        t.cls === 'array-buffer' || //TODO it could be wrong
        t.cls === 'typed-array' ||
        t.cls === 'data-view' || //TODO it could be wrong also
        t.cls === 'string'
      )) ||
      t.type === 'string';
  }

  function length(obj) {
    var t = getGlobalType(obj);
    switch (t.type) {
      case 'string':
        return obj.length;
      case 'object':
        switch (t.cls) {
          case 'array-buffer':
          case 'typed-array':
          case 'data-view':
            return obj.byteLength;

          case 'array':
          case 'buffer':
          case 'arguments':
          case 'function':
            return obj.length;
        }
    }
  }

  function convertPropertyName(name) {
    return (typeof name === 'symbol') ? name : String(name);
  }

  function isGeneratorObject(obj) {
    if (!obj) {
      return false;
    }

    return typeof obj.next === 'function' &&
            typeof obj[Symbol.iterator] === 'function' &&
            obj[Symbol.iterator]() === obj;
  }

  //TODO find better way
  function isGeneratorFunction(f) {
    return typeof f === 'function' && /^function\s*\*\s*/.test(f.toString());
  }

  function format(value, opts) {
    return config.getFormatter(opts).format(value);
  }

  var functionName = defaultFormat.Formatter.functionName;

  function formatProp(value) {
    return config.getFormatter().formatPropertyName(String(value));
  }


  var util = Object.freeze({
    isWrapperType: isWrapperType,
    merge: merge,
    forEach: forEach,
    some: some,
    isEmptyObject: isEmptyObject,
    isIndexable: isIndexable,
    length: length,
    convertPropertyName: convertPropertyName,
    isGeneratorObject: isGeneratorObject,
    isGeneratorFunction: isGeneratorFunction,
    format: format,
    functionName: functionName,
    formatProp: formatProp
  });

  /**
   * should AssertionError
   * @param {Object} options
   * @constructor
   * @memberOf should
   * @static
   */
  function AssertionError(options) {
    merge(this, options);

    if (!options.message) {
      Object.defineProperty(this, 'message', {
          get: function() {
            if (!this._message) {
              this._message = this.generateMessage();
              this.generatedMessage = true;
            }
            return this._message;
          },
          configurable: true,
          enumerable: false
        }
      );
    }

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.stackStartFunction);
    } else {
      // non v8 browsers so we can have a stacktrace
      var err = new Error();
      if (err.stack) {
        var out = err.stack;

        if (this.stackStartFunction) {
          // try to strip useless frames
          var fn_name = functionName(this.stackStartFunction);
          var idx = out.indexOf('\n' + fn_name);
          if (idx >= 0) {
            // once we have located the function frame
            // we need to strip out everything before it (and its line)
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }
        }

        this.stack = out;
      }
    }
  }


  var indent = '    ';
  function prependIndent(line) {
    return indent + line;
  }

  function indentLines(text) {
    return text.split('\n').map(prependIndent).join('\n');
  }


  // assert.AssertionError instanceof Error
  AssertionError.prototype = Object.create(Error.prototype, {
    name: {
      value: 'AssertionError'
    },

    generateMessage: {
      value: function() {
        if (!this.operator && this.previous) {
          return this.previous.message;
        }
        var actual = format(this.actual);
        var expected = 'expected' in this ? ' ' + format(this.expected) : '';
        var details = 'details' in this && this.details ? ' (' + this.details + ')' : '';

        var previous = this.previous ? '\n' + indentLines(this.previous.message) : '';

        return 'expected ' + actual + (this.negate ? ' not ' : ' ') + this.operator + expected + details + previous;
      }
    }
  });

  /**
   * should Assertion
   * @param {*} obj Given object for assertion
   * @constructor
   * @memberOf should
   * @static
   */
  function Assertion(obj) {
    this.obj = obj;

    this.anyOne = false;
    this.negate = false;

    this.params = {actual: obj};
  }

  Assertion.prototype = {
    constructor: Assertion,

    /**
     * Base method for assertions.
     *
     * Before calling this method need to fill Assertion#params object. This method usually called from other assertion methods.
     * `Assertion#params` can contain such properties:
     * * `operator` - required string containing description of this assertion
     * * `obj` - optional replacement for this.obj, it usefull if you prepare more clear object then given
     * * `message` - if this property filled with string any others will be ignored and this one used as assertion message
     * * `expected` - any object used when you need to assert relation between given object and expected. Like given == expected (== is a relation)
     * * `details` - additional string with details to generated message
     *
     * @memberOf Assertion
     * @category assertion
     * @param {*} expr Any expression that will be used as a condition for asserting.
     * @example
     *
     * var a = new should.Assertion(42);
     *
     * a.params = {
     *  operator: 'to be magic number',
     * }
     *
     * a.assert(false);
     * //throws AssertionError: expected 42 to be magic number
     */
    assert: function(expr) {
      if (expr) {
        return this;
      }

      var params = this.params;

      if ('obj' in params && !('actual' in params)) {
        params.actual = params.obj;
      } else if (!('obj' in params) && !('actual' in params)) {
        params.actual = this.obj;
      }

      params.stackStartFunction = params.stackStartFunction || this.assert;
      params.negate = this.negate;

      params.assertion = this;

      throw new AssertionError(params);
    },

    /**
     * Shortcut for `Assertion#assert(false)`.
     *
     * @memberOf Assertion
     * @category assertion
     * @example
     *
     * var a = new should.Assertion(42);
     *
     * a.params = {
     *  operator: 'to be magic number',
     * }
     *
     * a.fail();
     * //throws AssertionError: expected 42 to be magic number
     */
    fail: function() {
      return this.assert(false);
    }
  };



  /**
   * Assertion used to delegate calls of Assertion methods inside of Promise.
   * It has almost all methods of Assertion.prototype
   *
   * @param {Promise} obj
   */
  function PromisedAssertion(/* obj */) {
    Assertion.apply(this, arguments);
  }

  /**
   * Make PromisedAssertion to look like promise. Delegate resolve and reject to given promise.
   *
   * @private
   * @returns {Promise}
   */
  PromisedAssertion.prototype.then = function(resolve, reject) {
    return this.obj.then(resolve, reject);
  };

  /**
   * Way to extend Assertion function. It uses some logic
   * to define only positive assertions and itself rule with negative assertion.
   *
   * All actions happen in subcontext and this method take care about negation.
   * Potentially we can add some more modifiers that does not depends from state of assertion.
   *
   * @memberOf Assertion
   * @static
   * @param {String} name Name of assertion. It will be used for defining method or getter on Assertion.prototype
   * @param {Function} func Function that will be called on executing assertion
   * @example
   *
   * Assertion.add('asset', function() {
   *      this.params = { operator: 'to be asset' }
   *
   *      this.obj.should.have.property('id').which.is.a.Number()
   *      this.obj.should.have.property('path')
   * })
   */
  Assertion.add = function(name, func) {
    Object.defineProperty(Assertion.prototype, name, {
      enumerable: true,
      configurable: true,
      value: function() {
        var context = new Assertion(this.obj, this, name);
        context.anyOne = this.anyOne;

        try {
          func.apply(context, arguments);
        } catch (e) {
          // check for fail
          if (e instanceof AssertionError) {
            // negative fail
            if (this.negate) {
              this.obj = context.obj;
              this.negate = false;
              return this;
            }

            if (context !== e.assertion) {
              context.params.previous = e;
            }

            // positive fail
            context.negate = false;
            context.fail();
          }
          // throw if it is another exception
          throw e;
        }

        // negative pass
        if (this.negate) {
          context.negate = true; // because .fail will set negate
          context.params.details = 'false negative fail';
          context.fail();
        }

        // positive pass
        if (!this.params.operator) {
          this.params = context.params; // shortcut
        }
        this.obj = context.obj;
        this.negate = false;
        return this;
      }
    });

    Object.defineProperty(PromisedAssertion.prototype, name, {
      enumerable: true,
      configurable: true,
      value: function() {
        var args = arguments;
        this.obj = this.obj.then(function(a) {
          return a[name].apply(a, args);
        });

        return this;
      }
    });
  };

  /**
   * Add chaining getter to Assertion like .a, .which etc
   *
   * @memberOf Assertion
   * @static
   * @param  {string} name   name of getter
   * @param  {function} [onCall] optional function to call
   */
  Assertion.addChain = function(name, onCall) {
    onCall = onCall || function() {};
    Object.defineProperty(Assertion.prototype, name, {
      get: function() {
        onCall.call(this);
        return this;
      },
      enumerable: true
    });

    Object.defineProperty(PromisedAssertion.prototype, name, {
      enumerable: true,
      configurable: true,
      get: function() {
        this.obj = this.obj.then(function(a) {
          return a[name];
        });

        return this;
      }
    });
  };

  /**
   * Create alias for some `Assertion` property
   *
   * @memberOf Assertion
   * @static
   * @param {String} from Name of to map
   * @param {String} to Name of alias
   * @example
   *
   * Assertion.alias('true', 'True')
   */
  Assertion.alias = function(from, to) {
    var desc = Object.getOwnPropertyDescriptor(Assertion.prototype, from);
    if (!desc) {
      throw new Error('Alias ' + from + ' -> ' + to + ' could not be created as ' + from + ' not defined');
    }
    Object.defineProperty(Assertion.prototype, to, desc);

    var desc2 = Object.getOwnPropertyDescriptor(PromisedAssertion.prototype, from);
    if (desc2) {
      Object.defineProperty(PromisedAssertion.prototype, to, desc2);
    }
  };
  /**
   * Negation modifier. Current assertion chain become negated. Each call invert negation on current assertion.
   *
   * @name not
   * @property
   * @memberOf Assertion
   * @category assertion
   */
  Assertion.addChain('not', function() {
    this.negate = !this.negate;
  });

  /**
   * Any modifier - it affect on execution of sequenced assertion to do not `check all`, but `check any of`.
   *
   * @name any
   * @property
   * @memberOf Assertion
   * @category assertion
   */
  Assertion.addChain('any', function() {
    this.anyOne = true;
  });

  var pSlice = Array.prototype.slice;

  // 1. The assert module provides functions that throw
  // AssertionError's when particular conditions are not met. The
  // assert module must conform to the following interface.

  var assert = ok;
  // 3. All of the following functions must throw an AssertionError
  // when a corresponding condition is not met, with a message that
  // may be undefined if not provided.  All assertion methods provide
  // both the actual and expected values to the assertion error for
  // display purposes.
  /**
   * Node.js standard [`assert.fail`](http://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {*} actual Actual object
   * @param {*} expected Expected object
   * @param {string} message Message for assertion
   * @param {string} operator Operator text
   */
  function fail(actual, expected, message, operator, stackStartFunction) {
    var a = new Assertion(actual);
    a.params = {
      operator: operator,
      expected: expected,
      message: message,
      stackStartFunction: stackStartFunction || fail
    };

    a.fail();
  }

  // EXTENSION! allows for well behaved errors defined elsewhere.
  assert.fail = fail;

  // 4. Pure assertion tests whether a value is truthy, as determined
  // by !!guard.
  // assert.ok(guard, message_opt);
  // This statement is equivalent to assert.equal(true, !!guard,
  // message_opt);. To test strictly for the value true, use
  // assert.strictEqual(true, guard, message_opt);.
  /**
   * Node.js standard [`assert.ok`](http://nodejs.org/api/assert.html#assert_assert_value_message_assert_ok_value_message).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {*} value
   * @param {string} [message]
   */
  function ok(value, message) {
    if (!value) {
      fail(value, true, message, '==', assert.ok);
    }
  }
  assert.ok = ok;

  // 5. The equality assertion tests shallow, coercive equality with
  // ==.
  // assert.equal(actual, expected, message_opt);

  /**
   * Node.js standard [`assert.equal`](http://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   */
  assert.equal = function equal(actual, expected, message) {
    if (actual != expected) {
      fail(actual, expected, message, '==', assert.equal);
    }
  };

  // 6. The non-equality assertion tests for whether two objects are not equal
  // with != assert.notEqual(actual, expected, message_opt);
  /**
   * Node.js standard [`assert.notEqual`](http://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   */
  assert.notEqual = function notEqual(actual, expected, message) {
    if (actual == expected) {
      fail(actual, expected, message, '!=', assert.notEqual);
    }
  };

  // 7. The equivalence assertion tests a deep equality relation.
  // assert.deepEqual(actual, expected, message_opt);
  /**
   * Node.js standard [`assert.deepEqual`](http://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message).
   * But uses should.js .eql implementation instead of Node.js own deepEqual.
   *
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   */
  assert.deepEqual = function deepEqual(actual, expected, message) {
    if (eq(actual, expected).length !== 0) {
      fail(actual, expected, message, 'deepEqual', assert.deepEqual);
    }
  };


  // 8. The non-equivalence assertion tests for any deep inequality.
  // assert.notDeepEqual(actual, expected, message_opt);
  /**
   * Node.js standard [`assert.notDeepEqual`](http://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message).
   * But uses should.js .eql implementation instead of Node.js own deepEqual.
   *
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   */
  assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (eq(actual, expected).result) {
      fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
    }
  };

  // 9. The strict equality assertion tests strict equality, as determined by ===.
  // assert.strictEqual(actual, expected, message_opt);
  /**
   * Node.js standard [`assert.strictEqual`](http://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   */
  assert.strictEqual = function strictEqual(actual, expected, message) {
    if (actual !== expected) {
      fail(actual, expected, message, '===', assert.strictEqual);
    }
  };

  // 10. The strict non-equality assertion tests for strict inequality, as
  // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
  /**
   * Node.js standard [`assert.notStrictEqual`](http://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {*} actual
   * @param {*} expected
   * @param {string} [message]
   */
  assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (actual === expected) {
      fail(actual, expected, message, '!==', assert.notStrictEqual);
    }
  };

  function expectedException(actual, expected) {
    if (!actual || !expected) {
      return false;
    }

    if (Object.prototype.toString.call(expected) == '[object RegExp]') {
      return expected.test(actual);
    } else if (actual instanceof expected) {
      return true;
    } else if (expected.call({}, actual) === true) {
      return true;
    }

    return false;
  }

  function _throws(shouldThrow, block, expected, message) {
    var actual;

    if (typeof expected == 'string') {
      message = expected;
      expected = null;
    }

    try {
      block();
    } catch (e) {
      actual = e;
    }

    message = (expected && expected.name ? ' (' + expected.name + ')' : '.') +
    (message ? ' ' + message : '.');

    if (shouldThrow && !actual) {
      fail(actual, expected, 'Missing expected exception' + message);
    }

    if (!shouldThrow && expectedException(actual, expected)) {
      fail(actual, expected, 'Got unwanted exception' + message);
    }

    if ((shouldThrow && actual && expected && !expectedException(actual, expected)) || (!shouldThrow && actual)) {
      throw actual;
    }
  }

  // 11. Expected to throw an error:
  // assert.throws(block, Error_opt, message_opt);
  /**
   * Node.js standard [`assert.throws`](http://nodejs.org/api/assert.html#assert_assert_throws_block_error_message).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {Function} block
   * @param {Function} [error]
   * @param {String} [message]
   */
  assert.throws = function(/*block, error, message*/) {
    _throws.apply(this, [true].concat(pSlice.call(arguments)));
  };

  // EXTENSION! This is annoying to write outside this module.
  /**
   * Node.js standard [`assert.doesNotThrow`](http://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {Function} block
   * @param {String} [message]
   */
  assert.doesNotThrow = function(/*block, message*/) {
    _throws.apply(this, [false].concat(pSlice.call(arguments)));
  };

  /**
   * Node.js standard [`assert.ifError`](http://nodejs.org/api/assert.html#assert_assert_iferror_value).
   * @static
   * @memberOf should
   * @category assertion assert
   * @param {Error} err
   */
  assert.ifError = function(err) {
    if (err) {
      throw err;
    }
  };

  function assertExtensions(should) {
    var i = format;

    /*
     * Expose assert to should
     *
     * This allows you to do things like below
     * without require()ing the assert module.
     *
     *    should.equal(foo.bar, undefined);
     *
     */
    merge(should, assert);

    /**
     * Assert _obj_ exists, with optional message.
     *
     * @static
     * @memberOf should
     * @category assertion assert
     * @alias should.exists
     * @param {*} obj
     * @param {String} [msg]
     * @example
     *
     * should.exist(1);
     * should.exist(new Date());
     */
    should.exist = should.exists = function(obj, msg) {
      if (null == obj) {
        throw new AssertionError({
          message: msg || ('expected ' + i(obj) + ' to exist'), stackStartFunction: should.exist
        });
      }
    };

    should.not = {};
    /**
     * Asserts _obj_ does not exist, with optional message.
     *
     * @name not.exist
     * @static
     * @memberOf should
     * @category assertion assert
     * @alias should.not.exists
     * @param {*} obj
     * @param {String} [msg]
     * @example
     *
     * should.not.exist(null);
     * should.not.exist(void 0);
     */
    should.not.exist = should.not.exists = function(obj, msg) {
      if (null != obj) {
        throw new AssertionError({
          message: msg || ('expected ' + i(obj) + ' to not exist'), stackStartFunction: should.not.exist
        });
      }
    };
  }

  /*
   * should.js - assertion library
   * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
   * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
   * MIT Licensed
   */

  function chainAssertions(should, Assertion) {
    /**
     * Simple chaining. It actually do nothing.
     *
     * @memberOf Assertion
     * @name be
     * @property {should.Assertion} be
     * @alias Assertion#an
     * @alias Assertion#of
     * @alias Assertion#a
     * @alias Assertion#and
     * @alias Assertion#have
     * @alias Assertion#has
     * @alias Assertion#with
     * @alias Assertion#is
     * @alias Assertion#which
     * @alias Assertion#the
     * @alias Assertion#it
     * @category assertion chaining
     */
    ['an', 'of', 'a', 'and', 'be', 'has', 'have', 'with', 'is', 'which', 'the', 'it'].forEach(function(name) {
      Assertion.addChain(name);
    });
  }

  /*
   * should.js - assertion library
   * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
   * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
   * MIT Licensed
   */

  function booleanAssertions(should, Assertion) {
    /**
     * Assert given object is exactly `true`.
     *
     * @name true
     * @memberOf Assertion
     * @category assertion bool
     * @alias Assertion#True
     * @param {string} [message] Optional message
     * @example
     *
     * (true).should.be.true();
     * false.should.not.be.true();
     *
     * ({ a: 10}).should.not.be.true();
     */
    Assertion.add('true', function(message) {
      this.is.exactly(true, message);
    });

    Assertion.alias('true', 'True');

    /**
     * Assert given object is exactly `false`.
     *
     * @name false
     * @memberOf Assertion
     * @category assertion bool
     * @alias Assertion#False
     * @param {string} [message] Optional message
     * @example
     *
     * (true).should.not.be.false();
     * false.should.be.false();
     */
    Assertion.add('false', function(message) {
      this.is.exactly(false, message);
    });

    Assertion.alias('false', 'False');

    /**
     * Assert given object is thuthy according javascript type conversions.
     *
     * @name ok
     * @memberOf Assertion
     * @category assertion bool
     * @example
     *
     * (true).should.be.ok();
     * ''.should.not.be.ok();
     * should(null).not.be.ok();
     * should(void 0).not.be.ok();
     *
     * (10).should.be.ok();
     * (0).should.not.be.ok();
     */
    Assertion.add('ok', function() {
      this.params = { operator: 'to be truthy' };

      this.assert(this.obj);
    });
  }

  /*
   * should.js - assertion library
   * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
   * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
   * MIT Licensed
   */

  function numberAssertions(should, Assertion) {

    /**
     * Assert given object is NaN
     * @name NaN
     * @memberOf Assertion
     * @category assertion numbers
     * @example
     *
     * (10).should.not.be.NaN();
     * NaN.should.be.NaN();
     */
    Assertion.add('NaN', function() {
      this.params = { operator: 'to be NaN' };

      this.assert(this.obj !== this.obj);
    });

    /**
     * Assert given object is not finite (positive or negative)
     *
     * @name Infinity
     * @memberOf Assertion
     * @category assertion numbers
     * @example
     *
     * (10).should.not.be.Infinity();
     * NaN.should.not.be.Infinity();
     */
    Assertion.add('Infinity', function() {
      this.params = { operator: 'to be Infinity' };

      this.is.a.Number()
        .and.not.a.NaN()
        .and.assert(!isFinite(this.obj));
    });

    /**
     * Assert given number between `start` and `finish` or equal one of them.
     *
     * @name within
     * @memberOf Assertion
     * @category assertion numbers
     * @param {number} start Start number
     * @param {number} finish Finish number
     * @param {string} [description] Optional message
     * @example
     *
     * (10).should.be.within(0, 20);
     */
    Assertion.add('within', function(start, finish, description) {
      this.params = { operator: 'to be within ' + start + '..' + finish, message: description };

      this.assert(this.obj >= start && this.obj <= finish);
    });

    /**
     * Assert given number near some other `value` within `delta`
     *
     * @name approximately
     * @memberOf Assertion
     * @category assertion numbers
     * @param {number} value Center number
     * @param {number} delta Radius
     * @param {string} [description] Optional message
     * @example
     *
     * (9.99).should.be.approximately(10, 0.1);
     */
    Assertion.add('approximately', function(value, delta, description) {
      this.params = { operator: 'to be approximately ' + value + ' ' + delta, message: description };

      this.assert(Math.abs(this.obj - value) <= delta);
    });

    /**
     * Assert given number above `n`.
     *
     * @name above
     * @alias Assertion#greaterThan
     * @memberOf Assertion
     * @category assertion numbers
     * @param {number} n Margin number
     * @param {string} [description] Optional message
     * @example
     *
     * (10).should.be.above(0);
     */
    Assertion.add('above', function(n, description) {
      this.params = { operator: 'to be above ' + n, message: description };

      this.assert(this.obj > n);
    });

    /**
     * Assert given number below `n`.
     *
     * @name below
     * @alias Assertion#lessThan
     * @memberOf Assertion
     * @category assertion numbers
     * @param {number} n Margin number
     * @param {string} [description] Optional message
     * @example
     *
     * (0).should.be.below(10);
     */
    Assertion.add('below', function(n, description) {
      this.params = { operator: 'to be below ' + n, message: description };

      this.assert(this.obj < n);
    });

    Assertion.alias('above', 'greaterThan');
    Assertion.alias('below', 'lessThan');

    /**
     * Assert given number above `n`.
     *
     * @name aboveOrEqual
     * @alias Assertion#greaterThanOrEqual
     * @memberOf Assertion
     * @category assertion numbers
     * @param {number} n Margin number
     * @param {string} [description] Optional message
     * @example
     *
     * (10).should.be.aboveOrEqual(0);
     * (10).should.be.aboveOrEqual(10);
     */
    Assertion.add('aboveOrEqual', function(n, description) {
      this.params = { operator: 'to be above or equal' + n, message: description };

      this.assert(this.obj >= n);
    });

    /**
     * Assert given number below `n`.
     *
     * @name belowOrEqual
     * @alias Assertion#lessThanOrEqual
     * @memberOf Assertion
     * @category assertion numbers
     * @param {number} n Margin number
     * @param {string} [description] Optional message
     * @example
     *
     * (0).should.be.belowOrEqual(10);
     * (0).should.be.belowOrEqual(0);
     */
    Assertion.add('belowOrEqual', function(n, description) {
      this.params = { operator: 'to be below or equal' + n, message: description };

      this.assert(this.obj <= n);
    });

    Assertion.alias('aboveOrEqual', 'greaterThanOrEqual');
    Assertion.alias('belowOrEqual', 'lessThanOrEqual');

  }

  function typeAssertions(should, Assertion) {
    /**
     * Assert given object is number
     * @name Number
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('Number', function() {
      this.params = {operator: 'to be a number'};

      this.have.type('number');
    });

    /**
     * Assert given object is arguments
     * @name arguments
     * @alias Assertion#Arguments
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('arguments', function() {
      this.params = {operator: 'to be arguments'};

      this.have.class('Arguments');
    });

    Assertion.alias('arguments', 'Arguments');

    /**
     * Assert given object has some type using `typeof`
     * @name type
     * @memberOf Assertion
     * @param {string} type Type name
     * @param {string} [description] Optional message
     * @category assertion types
     */
    Assertion.add('type', function(type, description) {
      this.params = {operator: 'to have type ' + type, message: description};

      should(typeof this.obj).be.exactly(type);
    });

    /**
     * Assert given object is instance of `constructor`
     * @name instanceof
     * @alias Assertion#instanceOf
     * @memberOf Assertion
     * @param {Function} constructor Constructor function
     * @param {string} [description] Optional message
     * @category assertion types
     */
    Assertion.add('instanceof', function(constructor, description) {
      this.params = {operator: 'to be an instance of ' + functionName(constructor), message: description};

      this.assert(Object(this.obj) instanceof constructor);
    });

    Assertion.alias('instanceof', 'instanceOf');

    /**
     * Assert given object is function
     * @name Function
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('Function', function() {
      this.params = {operator: 'to be a function'};

      this.have.type('function');
    });

    /**
     * Assert given object is object
     * @name Object
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('Object', function() {
      this.params = {operator: 'to be an object'};

      this.is.not.null().and.have.type('object');
    });

    /**
     * Assert given object is string
     * @name String
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('String', function() {
      this.params = {operator: 'to be a string'};

      this.have.type('string');
    });

    /**
     * Assert given object is array
     * @name Array
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('Array', function() {
      this.params = {operator: 'to be an array'};

      this.have.class('Array');
    });

    /**
     * Assert given object is boolean
     * @name Boolean
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('Boolean', function() {
      this.params = {operator: 'to be a boolean'};

      this.have.type('boolean');
    });

    /**
     * Assert given object is error
     * @name Error
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('Error', function() {
      this.params = {operator: 'to be an error'};

      this.have.instanceOf(Error);
    });

    /**
     * Assert given object is a date
     * @name Date
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('Date', function() {
      this.params = {operator: 'to be a date'};

      this.have.instanceOf(Date);
    });

    /**
     * Assert given object is null
     * @name null
     * @alias Assertion#Null
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('null', function() {
      this.params = {operator: 'to be null'};

      this.assert(this.obj === null);
    });

    Assertion.alias('null', 'Null');

    /**
     * Assert given object has some internal [[Class]], via Object.prototype.toString call
     * @name class
     * @alias Assertion#Class
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('class', function(cls) {
      this.params = {operator: 'to have [[Class]] ' + cls};

      this.assert(Object.prototype.toString.call(this.obj) === '[object ' + cls + ']');
    });

    Assertion.alias('class', 'Class');

    /**
     * Assert given object is undefined
     * @name undefined
     * @alias Assertion#Undefined
     * @memberOf Assertion
     * @category assertion types
     */
    Assertion.add('undefined', function() {
      this.params = {operator: 'to be undefined'};

      this.assert(this.obj === void 0);
    });

    Assertion.alias('undefined', 'Undefined');

    /**
     * Assert given object supports es6 iterable protocol (just check
     * that object has property Symbol.iterator, which is a function)
     * @name iterable
     * @memberOf Assertion
     * @category assertion es6
     */
    Assertion.add('iterable', function() {
      this.params = {operator: 'to be iterable'};

      should(this.obj).have.property(Symbol.iterator).which.is.a.Function();
    });

    /**
     * Assert given object supports es6 iterator protocol (just check
     * that object has property next, which is a function)
     * @name iterator
     * @memberOf Assertion
     * @category assertion es6
     */
    Assertion.add('iterator', function() {
      this.params = {operator: 'to be iterator'};

      should(this.obj).have.property('next').which.is.a.Function();
    });

    /**
     * Assert given object is a generator object
     * @name generator
     * @memberOf Assertion
     * @category assertion es6
     */
    Assertion.add('generator', function() {
      this.params = {operator: 'to be generator'};

      should(this.obj).be.iterable
        .and.iterator
        .and.it.is.equal(this.obj[Symbol.iterator]());
    });
  }

  function formatEqlResult(r, a, b) {
    return ((r.path.length > 0 ? 'at ' + r.path.map(formatProp).join(' -> ') : '') +
    (r.a === a ? '' : ', A has ' + format(r.a)) +
    (r.b === b ? '' : ' and B has ' + format(r.b)) +
    (r.showReason ? ' because ' + r.reason : '')).trim();
  }

  function equalityAssertions(should, Assertion) {

    /**
     * Deep object equality comparison. For full spec see [`should-equal tests`](https: